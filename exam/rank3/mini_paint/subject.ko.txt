할당명 : mini_paint
필요한 파일: *.c *.h
허용되는 함수: fopen, fread, fscanf, flose, write, malloc, calloc, realloc, free, memset, powf, sqrtf
--------------------------------------------------------------------------------------

"작업 파일"을 읽고 그 결과를 터미널에 출력하는 프로그램을 작성한다.

프로그램에서 하나의 인수를 사용해야 합니다. 이 인수는 "작업 파일"에 대한 경로입니다.
프로그램에 0개 이상의 인수가 지정된 경우 "Error: argument"를 입력한 후 STDOUT에 \n을 입력합니다.

$> ./mini_pairs | cat-e
오류: 인수 $
$> ./mini_filename 수학 | cat-e
오류: 인수 $
$>

"작업 파일"을 열거나 읽는 동안 문제가 발생하면 "오류: 작업 파일이 손상됨"을 입력한 다음 STDOUT에 \n을 입력합니다.

작업 파일에는 한 줄당 한 번의 작업이 포함된 줄이 포함됩니다.
선이 올바르지 않으면 오류가 발생합니다.
오류가 발생한 경우 프로그램은 1을 반환해야 합니다.
오류가 발생하지 않으면 0을 반환해야 합니다.
마지막 줄은 \n과 함께 또는 없이 될 수 있습니다.
라인은 순서대로 읽어야 하므로 작업은 동일한 순서로 실행되어야 합니다.
한 줄의 각 변수 사이에 하나 이상의 공백이 있어야 합니다.

폭 높이 배경_CHAR
이 줄은 항상 파일의 첫 번째 줄이며 그릴 영역을 정의합니다. 프로그램이 그리기 영역 외부에 아무것도 표시하지 않아야 합니다. 한 번만 있어야 합니다.
- WIDTH: 0 < WIDTH < = 300의 인트여야 하며, 그리기 영역에 사용할 수평 문자 수
- HEIGHT: 0 < HEIGH < = 300의 인트여야 하며, 그리기 영역에 사용할 수직 문자 수
- BACKGROUND_CHAR: 빈 공간은 BACKGROUND_CHAR로 채워집니다.

c XY RADIUS 문자
이 작업을 수행하면 원의 테두리만 그려지는 빈 원이 그려집니다.
- c: 문자 c
- X: 원 중심의 수평 위치인 플로트
- Y: 원 중심 수직 위치인 플로트
- RADIUS: 0이 아닌 양의 플로트, 원의 반지름
- CAR: 원을 그릴 수 있는 부적

XY RADIUS 문자
이 작업을 수행하면 채워진 원이 그려집니다.
- C: 문자 C
- X: 원 중심의 수평 위치인 플로트
- Y: 원 중심 수직 위치인 플로트
- RADIUS: 0이 아닌 양의 플로트, 원의 반지름
- CAR: 원을 그릴 수 있는 부적


그리기 영역은 각각 하나의 문자를 포함할 수 있는 직사각형으로 분할됩니다(단말기에 있으므로...). 픽셀이라고 합니다.
모든 것을 더 쉽게 하기 위해, 우리는 픽셀의 왼쪽 상단 모서리만을 사용하여 그 픽셀이 원 안에 있는지 아닌지를 알 것이다.
픽셀의 왼쪽 상단 모서리와 원의 중심 사이의 거리가 원의 반지름보다 낮거나 같으면 픽셀은 원의 일부입니다.
또한 다음과 같습니다.
원의 경계에서 거리가 1보다 크거나 같은 왼쪽 상단 모서리의 픽셀은 빈 원의 일부가 아닙니다.
원의 경계에서 거리가 1보다 작은 왼쪽 상단 모서리의 픽셀은 빈 원의 일부입니다.

다음 몇 줄을 읽으면서 이미지를 봐야 합니다. 터미널을 나타냅니다. 드로잉 존을 WIDTY 5와 HEIGHT 3으로 설정했습니다.
다음 설명을 이해하기 위해 다른 문자를 작성했습니다.
- 연산을 그리려면 C 1.5 1.5 10 @(핑크 원)
-- 이는 이미지의 'b', 'c', 'B', 'C' 문자가 '@'로 대체됨을 의미합니다.

operation_file.example로 테스트하는 데 도움이 되는 our_mini_paint를 찾아야 합니다.

힌트:
2개의 점이 있으면 (Xa, Ya) 및 (Xb, Yb)로 정의됩니다.
srqt((Xa - Xb) * (Xa - Xb) + (Ya - Yb) * (Ya - Yb)) 공식을 사용하여 두 점 사이의 거리를 구할 수 있습니다.